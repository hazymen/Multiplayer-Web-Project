<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MPCad</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        #room-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        #room-selection-dialog {
            background: #fff;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 500px;
        }
        #room-selection-dialog h2 {
            margin: 0 0 20px 0;
            color: #333;
        }
        #room-selection-dialog p {
            margin: 0 0 20px 0;
            color: #666;
            font-size: 14px;
        }
        #room-list {
            margin: 20px 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
        }
        .room-item {
            padding: 10px;
            margin: 5px 0;
            background: #f5f5f5;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .room-item:hover {
            background: #e0e0e0;
        }
        .room-item input[type="radio"] {
            margin-right: 8px;
        }
        #room-enter-btn {
            background: #2196f3;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #room-enter-btn:hover {
            background: #1976d2;
        }
        #main-ui {
            display: none;
        }
        #current-room-info {
            position: absolute;
            top: 5px;
            right: 10px;
            color: #666;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <!-- 部屋選択モーダル -->
    <div id="room-selection-modal">
        <div id="room-selection-dialog">
            <h2>部屋を選択</h2>
            <p>保存済みプロジェクトから入室する部屋を選択してください</p>
            <div id="room-list"></div>
            <button id="room-enter-btn">入室</button>
        </div>
    </div>

    <!-- メインUI -->
    <div id="main-ui">
        <div id="current-room-info"></div>
        <div id="menu-bar">
            <p>MPCad</p>
            <div style="display:inline-block;margin-left:24px;">
                <input id="project-name-input" type="text" placeholder="プロジェクト名" style="width:120px;padding:4px 8px;border-radius:4px;border:1px solid #ccc;font-size:14px;">
                <button id="save-project-btn" style="background:#43a047;color:#fff;border:none;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:14px;margin-left:4px;">保存</button>
            </div>
            <div class="dropdown" id="add-dropdown">
                <button class="dropdown-btn">追加</button>
                <div class="dropdown-content">
                    <button id="add-cube">立方体</button>
                    <button id="add-sphere">球体</button>
                    <button id="add-plane">平面</button>
                    <button id="add-glb">モデル</button>
                </div>
            </div>
            <button id="delete-btn" style="margin-left:12px;background:#e53935;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-size:16px;">削除</button>
            <button id="mode-switch" style="margin-left:12px;background:#2196f3;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-size:16px;">通常</button>
        </div>
        <div id="mode-bar">
            <button id="mode-move" class="active mode-btn" style="position:relative;">移動</button>
            <button id="mode-scale" class="mode-btn">寸法</button>
            <button id="mode-rotate" class="mode-btn">回転</button>
            <div id="move-coord-ui" style="display:none;">
                <label style="color:#fff;font-size:12px;">X</label>
                <input id="move-x" type="number" step="0.1" style="width:48px; font-size:12px; margin-right:2px;">
                <label style="color:#fff;font-size:12px;">Y</label>
                <input id="move-y" type="number" step="0.1" style="width:48px; font-size:12px; margin-right:2px;">
                <label style="color:#fff;font-size:12px;">Z</label>
                <input id="move-z" type="number" step="0.1" style="width:48px; font-size:12px; margin-right:2px;">
                <button id="move-apply" style="font-size:12px; padding:2px 8px; border-radius:4px; background:#ff9800; color:#222; border:none; cursor:pointer;">移動</button>
            </div>
        </div>
        <div id="custom-alert"></div>
    </div>

    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        let objects = {};
        let currentRoom = null;
        let renderer, scene, camera, controls, transformControls;
        const socket = io();
        
        // --- 部屋選択ロジック ---
        async function initializeRoomSelection() {
            try {
                // 仮の実装：a,b,cのみ選択可能
                const rooms = ['a', 'b', 'c'];
                const roomList = document.getElementById('room-list');
                roomList.innerHTML = '';
                rooms.forEach((roomName, index) => {
                    const label = document.createElement('label');
                    label.className = 'room-item';
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = 'room';
                    radio.value = roomName;
                    if (index === 0) radio.checked = true;
                    label.appendChild(radio);
                    label.appendChild(document.createTextNode(roomName));
                    roomList.appendChild(label);
                });
            } catch (error) {
                console.error('部屋一覧の取得に失敗:', error);
            }
        }
        
        document.getElementById('room-enter-btn').onclick = async function() {
            const selected = document.querySelector('input[name="room"]:checked');
            if (!selected) {
                alert('部屋を選択してください');
                return;
            }
            currentRoom = selected.value;
            
            // バックエンドに部屋参加を通知
            socket.emit('join_room', { room_name: currentRoom });
            
            // 部屋選択モーダルを非表示、メインUIを表示
            document.getElementById('room-selection-modal').style.display = 'none';
            document.getElementById('main-ui').style.display = 'block';
            
            // 現在の部屋情報を表示
            document.getElementById('current-room-info').textContent = `部屋: ${currentRoom}`;
            
            // Three.jsのレンダリング開始
            startThreeJsRendering();
        };
        
        // ページロード時に部屋一覧を取得
        initializeRoomSelection();
        
        // --- Three.js初期化を遅延して実行 ---
        function startThreeJsRendering() {
            // --- Three.js初期化 ---
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.marginTop = '48px';
            document.getElementById('main-ui').appendChild(renderer.domElement);
            camera.position.z = 5;
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = 1;
            controls.maxDistance = 1000;
            
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            scene.add(transformControls);
            transformControls.setMode('translate');
            transformControls.visible = false;
            transformControls.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                if (!event.value) {
                    transformControls.dragging = false;
                    controls.enabled = true;
                }
            });

            window.addEventListener('pointerup', function() {
                if (transformControls.dragging) {
                    transformControls.dragging = false;
                    controls.enabled = true;
                }
            });
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            const gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0x444444);
            gridHelper.position.set(0, 0, 0);
            scene.add(gridHelper);
            
            setupSocketAndEvents();
            animate();
        }
        
        // --- 面編集用ハンドル ---
        let faceHandles = [];
        function showFaceHandles(mesh) {
            removeFaceHandles();
            if (mesh.type === 'Group' || mesh.type === 'Scene') {
                return;
            }
            if (mesh.geometry && mesh.geometry.attributes && mesh.geometry.attributes.position && mesh.geometry.index) {
                _showFaceHandlesForMesh(mesh);
            }
        }

        function _showFaceHandlesForMesh(mesh) {
            const posAttr = mesh.geometry.attributes.position;
            const indexAttr = mesh.geometry.index;
            for (let i = 0; i < indexAttr.count; i += 3) {
                const a = indexAttr.getX(i);
                const b = indexAttr.getX(i + 1);
                const c = indexAttr.getX(i + 2);
                const va = new THREE.Vector3().fromBufferAttribute(posAttr, a);
                const vb = new THREE.Vector3().fromBufferAttribute(posAttr, b);
                const vc = new THREE.Vector3().fromBufferAttribute(posAttr, c);
                const center = new THREE.Vector3().addVectors(va, vb).add(vc).divideScalar(3).applyMatrix4(mesh.matrixWorld);
                const handleGeom = new THREE.SphereGeometry(0.09, 12, 12);
                const handleMat = new THREE.MeshBasicMaterial({ color: 0xff9800 });
                const handle = new THREE.Mesh(handleGeom, handleMat);
                handle.position.copy(center);
                handle.userData.faceIndices = [a, b, c];
                handle.userData.parentMesh = mesh;
                handle.userData.faceIndex = i / 3;
                faceHandles.push(handle);
                scene.add(handle);
            }
        }

        function removeFaceHandles() {
            if (scene) {
                faceHandles.forEach(h => scene.remove(h));
            }
            faceHandles = [];
        }

        // 面ハンドルのドラッグ処理
        let draggingHandle = null;
        let dragOffset = new THREE.Vector3();
        let dragPrevPositions = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer?.domElement?.addEventListener('pointerdown', (event) => {
            if (!faceHandles || faceHandles.length === 0) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(faceHandles, false);
            if (intersects.length > 0) {
                draggingHandle = intersects[0].object;
                dragOffset.copy(draggingHandle.position);
                controls.enabled = false;
                const mesh = draggingHandle.userData.parentMesh;
                const indices = draggingHandle.userData.faceIndices;
                const posAttr = mesh.geometry.attributes.position;
                dragPrevPositions = indices.map(idx => {
                    return new THREE.Vector3().fromBufferAttribute(posAttr, idx);
                });
            }
        });

        renderer?.domElement?.addEventListener('pointermove', (event) => {
            if (!draggingHandle) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane();
            plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), draggingHandle.position);
            const pointer = new THREE.Vector2(mouse.x, mouse.y);
            const ray = raycaster.ray;
            const intersection = new THREE.Vector3();
            if (ray.intersectPlane(plane, intersection)) {
                const delta = new THREE.Vector3().subVectors(intersection, draggingHandle.position);
                draggingHandle.position.copy(intersection);
                const mesh = draggingHandle.userData.parentMesh;
                const indices = draggingHandle.userData.faceIndices;
                const posAttr = mesh.geometry.attributes.position;
                indices.forEach((idx, i) => {
                    const prev = dragPrevPositions[i];
                    posAttr.setXYZ(idx, prev.x + delta.x, prev.y + delta.y, prev.z + delta.z);
                });
                mesh.geometry.attributes.position.needsUpdate = true;
                if (mesh.userData.serverId !== undefined) {
                    let childMeshIndex = undefined;
                    if ((mesh.parent && (mesh.parent.type === 'Group' || mesh.parent.type === 'Scene')) || mesh.type === 'Mesh') {
                        const parent = mesh.parent;
                        if (parent && parent.children) {
                            childMeshIndex = parent.children.indexOf(mesh);
                        }
                    }
                    socket.emit('edit_face', {
                        id: mesh.userData.serverId,
                        face_indices: indices,
                        delta: { x: delta.x, y: delta.y, z: delta.z },
                        childMeshIndex: childMeshIndex
                    });
                }
            }
        });

        renderer?.domElement?.addEventListener('pointerup', () => {
            if (draggingHandle) {
                if (dragPrevPositions) {
                    const mesh = draggingHandle.userData.parentMesh;
                    const indices = draggingHandle.userData.faceIndices;
                    pushUndo({
                        type: 'face',
                        mesh: mesh,
                        indices: [...indices],
                        prev: dragPrevPositions.map(v => v.clone())
                    });
                }
                draggingHandle = null;
                dragPrevPositions = null;
                controls.enabled = true;
            }
        });

        // --- 削除ボタン処理 ---
        document.getElementById('delete-btn').onclick = function() {
            if (!selectedObjects || selectedObjects.length === 0) {
                showCustomAlert('削除するオブジェクトを選択してください', window.innerWidth/2, 60);
                return;
            }
            selectedObjects.forEach(obj => {
                if (obj.userData && obj.userData.serverId) {
                    socket.emit('delete_object', { id: obj.userData.serverId });
                }
            });
        };
        
        // --- モード管理 ---
        let drawMode = false;
        let opMode = 'move';
        let savedCameraPosition = null;
        let savedCameraUp = null;
        let savedControlsTarget = null;

        document.getElementById('mode-move').onclick = () => setOpMode('move');
        document.getElementById('mode-scale').onclick = () => setOpMode('scale');
        document.getElementById('mode-rotate').onclick = () => setOpMode('rotate');
        document.getElementById('mode-switch').onclick = () => setDrawMode(!drawMode);

        function setDrawMode(on) {
            if (drawMode === on) return;
            drawMode = on;
            transformControls.detach();
            controls.enabled = true;
            
            const switchBtn = document.getElementById('mode-switch');
            if (drawMode) {
                switchBtn.textContent = '作図';
                switchBtn.style.background = '#ff9800';
                savedCameraPosition = camera.position.clone();
                savedCameraUp = camera.up.clone();
                savedControlsTarget = controls.target.clone();
                camera.position.set(0, 20, 0);
                camera.up.set(0, 0, -1);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.enableRotate = false;
                controls.enablePan = true;
                controls.enableZoom = true;
            } else {
                switchBtn.textContent = '通常';
                switchBtn.style.background = '#2196f3';
                if (savedCameraPosition && savedCameraUp && savedControlsTarget) {
                    camera.position.copy(savedCameraPosition);
                    camera.up.copy(savedCameraUp);
                    camera.lookAt(savedControlsTarget);
                    controls.target.copy(savedControlsTarget);
                }
                controls.enableRotate = true;
                controls.enablePan = true;
                controls.enableZoom = true;
                savedCameraPosition = null;
                savedCameraUp = null;
                savedControlsTarget = null;
            }
            updateTransformControls();
            updateModeBarUI();
        }

        function setOpMode(newMode) {
            if (opMode === newMode) return;
            opMode = newMode;
            updateModeBarUI();
            updateTransformControls();
        }

        function updateModeBarUI() {
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            if (opMode === 'move') document.getElementById('mode-move').classList.add('active');
            if (opMode === 'scale') document.getElementById('mode-scale').classList.add('active');
            if (opMode === 'rotate') document.getElementById('mode-rotate').classList.add('active');
            const moveUI = document.getElementById('move-coord-ui');
            if (opMode === 'move' && selectedObject) {
                const moveBtn = document.getElementById('mode-move');
                const bar = document.getElementById('mode-bar');
                const btnRect = moveBtn.getBoundingClientRect();
                const barRect = bar.getBoundingClientRect();
                moveUI.style.left = (barRect.right - barRect.left) + 'px';
                moveUI.style.top = (moveBtn.offsetTop) + 'px';
                moveUI.style.display = '';
                updateMoveCoordUI();
            } else {
                moveUI.style.display = 'none';
            }
        }

        function updateTransformControls() {
            transformControls.detach();
            if (!selectedObject) {
                transformControls.visible = false;
                return;
            }
            if (opMode === 'move') {
                transformControls.attach(selectedObject);
                transformControls.setMode('translate');
                transformControls.visible = true;
            } else if (opMode === 'scale') {
                transformControls.attach(selectedObject);
                transformControls.setMode('scale');
                transformControls.visible = true;
            } else if (opMode === 'rotate') {
                transformControls.attach(selectedObject);
                transformControls.setMode('rotate');
                transformControls.visible = true;
            } else {
                transformControls.visible = false;
            }
        }

        function showCustomAlert(msg, x, y) {
            const alertDiv = document.getElementById('custom-alert');
            alertDiv.textContent = msg;
            alertDiv.style.left = x + 12 + 'px';
            alertDiv.style.top = y + 12 + 'px';
            alertDiv.style.display = 'block';
            alertDiv.style.opacity = '1';
            setTimeout(() => {
                alertDiv.style.opacity = '0';
                setTimeout(() => { alertDiv.style.display = 'none'; }, 200);
            }, 1200);
        }

        // Socket.IOイベント設定
        function setupSocketAndEvents() {
            const idToObject = {};
            const selectableObjects = [];
            let selectedObjects = [];
            let selectedObject = null;
            const selectedBy = {};
            let mySid = null;

            socket.on('connect', () => {
                mySid = socket.id;
            });

            socket.on('init_objects', (objs) => {
                objs.forEach(obj => {
                    createObjectFromServer(obj, idToObject, selectableObjects);
                });
            });

            socket.on('add_object', (obj) => {
                createObjectFromServer(obj, idToObject, selectableObjects);
            });

            socket.on('move_object', (data) => {
                const obj = idToObject[data.id];
                if (obj) {
                    if (data.position) obj.position.set(data.position.x, data.position.y, data.position.z);
                    if (data.rotation) obj.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                    if (data.scale) obj.scale.set(data.scale.x, data.scale.y, data.scale.z);
                    updateObjectState(data.id, obj);
                    updateMoveCoordUI();
                }
            });

            socket.on('rotate_object', (data) => {
                const obj = idToObject[data.id];
                if (obj) {
                    if (data.rotation) obj.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                    if (data.position) obj.position.set(data.position.x, data.position.y, data.position.z);
                    if (data.scale) obj.scale.set(data.scale.x, data.scale.y, data.scale.z);
                    updateObjectState(data.id, obj);
                }
            });

            socket.on('scale_object', (data) => {
                const obj = idToObject[data.id];
                if (obj) {
                    if (data.scale) obj.scale.set(data.scale.x, data.scale.y, data.scale.z);
                    if (data.position) obj.position.set(data.position.x, data.position.y, data.position.z);
                    if (data.rotation) obj.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                    updateObjectState(data.id, obj);
                }
            });

            socket.on('edit_face', (data) => {
                const obj = idToObject[data.id];
                if (!obj) return;
                let targetMesh = obj;
                if (typeof data.childMeshIndex === 'number' && (obj.type === 'Group' || obj.type === 'Scene') && obj.children[data.childMeshIndex]) {
                    targetMesh = obj.children[data.childMeshIndex];
                }
                if (!targetMesh.geometry || !targetMesh.geometry.attributes || !targetMesh.geometry.attributes.position) return;
                const indices = data.face_indices;
                const delta = data.delta;
                indices.forEach(idx => {
                    const posAttr = targetMesh.geometry.attributes.position;
                    const prev = new THREE.Vector3().fromBufferAttribute(posAttr, idx);
                    posAttr.setXYZ(idx, prev.x + delta.x, prev.y + delta.y, prev.z + delta.z);
                });
                targetMesh.geometry.attributes.position.needsUpdate = true;
                if (faceHandles) {
                    for (let h = 0; h < faceHandles.length; h++) {
                        const handle = faceHandles[h];
                        if (handle.userData.parentMesh === targetMesh && JSON.stringify(handle.userData.faceIndices) === JSON.stringify(indices)) {
                            const posAttr = targetMesh.geometry.attributes.position;
                            const va = new THREE.Vector3().fromBufferAttribute(posAttr, indices[0]);
                            const vb = new THREE.Vector3().fromBufferAttribute(posAttr, indices[1]);
                            const vc = new THREE.Vector3().fromBufferAttribute(posAttr, indices[2]);
                            const center = new THREE.Vector3().addVectors(va, vb).add(vc).divideScalar(3).applyMatrix4(targetMesh.matrixWorld);
                            handle.position.copy(center);
                            break;
                        }
                    }
                }
            });

            socket.on('object_deleted', (data) => {
                const obj = idToObject[data.id];
                if (obj) {
                    scene.remove(obj);
                    const idx = selectableObjects.indexOf(obj);
                    if (idx >= 0) selectableObjects.splice(idx, 1);
                    delete idToObject[data.id];
                    if (objects[data.id]) delete objects[data.id];
                    setSelectedObjects([]);
                }
            });

            socket.on('object_selected', ({id, sid}) => {
                selectedBy[id] = sid;
                const obj = idToObject[id];
                if (obj && sid !== mySid) {
                    if (obj.type === 'Group' || obj.type === 'Scene') {
                        obj.traverse(child => {
                            if (child.isMesh) {
                                child.material.color.setHex(0xff0000);
                                child.material.emissive.setHex(0x330000);
                            }
                        });
                    } else if (obj.material) {
                        obj.material.color.setHex(0xff0000);
                        obj.material.emissive.setHex(0x330000);
                    }
                }
            });

            socket.on('object_deselected', ({id}) => {
                delete selectedBy[id];
                const obj = idToObject[id];
                if (obj) {
                    if (obj.type === 'Group' || obj.type === 'Scene') {
                        obj.traverse(child => {
                            if (child.isMesh && objects[id] && objects[id].color) {
                                child.material.color.setHex(objects[id].color);
                                child.material.emissive.setHex(0x000000);
                            }
                        });
                    } else if (obj.material && objects[id] && objects[id].color) {
                        obj.material.color.setHex(objects[id].color);
                        obj.material.emissive.setHex(0x000000);
                    }
                }
            });

            socket.on('select_result', ({id, result}) => {
                if (!result && idToObject[id]) {
                    const obj = idToObject[id];
                    if (selectedObjects.includes(obj)) {
                        setSelectedObjects(selectedObjects.filter(o => o !== obj));
                    }
                }
            });

            // オブジェクト選択処理
            renderer.domElement.addEventListener('pointerdown', (event) => {
                if (transformControls.dragging) return;
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(selectableObjects, true);
                if (intersects.length > 0) {
                    let clickedMesh = intersects[0].object;
                    while (clickedMesh && !selectableObjects.includes(clickedMesh)) {
                        clickedMesh = clickedMesh.parent;
                    }
                    if (clickedMesh && selectableObjects.includes(clickedMesh)) {
                        if (selectedObjects.includes(clickedMesh)) {
                            setSelectedObjects(selectedObjects.filter(o => o !== clickedMesh));
                            socket.emit('deselect_object', { id: clickedMesh.userData.serverId });
                        } else {
                            setSelectedObjects([...selectedObjects, clickedMesh]);
                            socket.emit('select_object', { id: clickedMesh.userData.serverId });
                        }
                    }
                } else {
                    setSelectedObjects([]);
                }
            });

            function setSelectedObjects(objs) {
                if (selectedObjects && selectedObjects.length > 0) {
                    selectedObjects.forEach(obj => {
                        if (obj.type === 'Group' || obj.type === 'Scene') {
                            obj.traverse(child => {
                                if (child.isMesh && objects[obj.userData.serverId] && objects[obj.userData.serverId].color) {
                                    child.material.color.setHex(objects[obj.userData.serverId].color);
                                    child.material.emissive.setHex(0x000000);
                                }
                            });
                        } else if (obj.material && objects[obj.userData.serverId] && objects[obj.userData.serverId].color) {
                            obj.material.color.setHex(objects[obj.userData.serverId].color);
                            obj.material.emissive.setHex(0x000000);
                        }
                    });
                }
                selectedObjects = objs ? [...objs] : [];
                selectedObject = selectedObjects.length > 0 ? selectedObjects[0] : null;
                updateModeBarUI();
                updateTransformControls();
                if (selectedObjects.length > 0) {
                    selectedObjects.forEach(obj => {
                        if (obj.type === 'Group' || obj.type === 'Scene') {
                            obj.traverse(child => {
                                if (child.isMesh) {
                                    child.material.color.setHex(0x00ffff);
                                    child.material.emissive.setHex(0x003333);
                                }
                            });
                        } else if (obj.material) {
                            obj.material.color.setHex(0x00ffff);
                            obj.material.emissive.setHex(0x003333);
                        }
                    });
                }
            }

            function updateMoveCoordUI() {
                if (!selectedObject) return;
                document.getElementById('move-x').value = selectedObject.position.x.toFixed(3);
                document.getElementById('move-y').value = selectedObject.position.y.toFixed(3);
                document.getElementById('move-z').value = selectedObject.position.z.toFixed(3);
            }

            document.getElementById('move-apply').onclick = function() {
                if (!selectedObject) return;
                const x = parseFloat(document.getElementById('move-x').value);
                const y = parseFloat(document.getElementById('move-y').value);
                const z = parseFloat(document.getElementById('move-z').value);
                if (isNaN(x) || isNaN(y) || isNaN(z)) return;
                pushUndo({
                    type: 'move',
                    objs: [...selectedObjects],
                    prevPositions: selectedObjects.map(obj => obj.position.clone())
                });
                selectedObjects.forEach(obj => {
                    obj.position.set(x, y, z);
                    socket.emit('move_object', {
                        id: obj.userData.serverId,
                        position: { x: obj.position.x, y: obj.position.y, z: obj.position.z }
                    });
                });
                updateMoveCoordUI();
            };

            transformControls.addEventListener('objectChange', function () {
                if (opMode === 'move' && selectedObject) {
                    updateMoveCoordUI();
                }
            });

            socket.on('move_object', (data) => {
                const obj = idToObject[data.id];
                if (obj) {
                    updateMoveCoordUI();
                }
            });

            function addCube() {
                socket.emit('add_object', {
                    type: 'cube',
                    position: { x: 0, y: 0, z: 0 },
                    color: 0x00ff00
                });
            }

            function addSphere() {
                socket.emit('add_object', {
                    type: 'sphere',
                    position: { x: 0, y: 0, z: 0 },
                    color: 0x2196f3
                });
            }

            function addPlane() {
                socket.emit('add_object', {
                    type: 'plane',
                    position: { x: 0, y: 0, z: 0 },
                    color: 0x9e9e9e
                });
            }

            document.getElementById('add-cube').onclick = addCube;
            document.getElementById('add-sphere').onclick = addSphere;
            document.getElementById('add-plane').onclick = addPlane;
            document.getElementById('add-glb').onclick = addGLB;

            function addGLB() {
                socket.emit('add_object', {
                    type: 'glb',
                    position: { x: 0, y: 0, z: 0 },
                    modelName: 'test_obj.glb',
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
            }

            document.getElementById('save-project-btn').onclick = async function() {
                const name = document.getElementById('project-name-input').value.trim();
                if (!name) {
                    showCustomAlert('プロジェクト名を入力してください', window.innerWidth/2, 60);
                    return;
                }
                
                // 現在入室している部屋のみ保存可能
                if (!currentRoom) {
                    showCustomAlert('部屋に入室してください', window.innerWidth/2, 60);
                    return;
                }
                
                const objectsToSave = {};
                for (const id in idToObject) {
                    const mesh = idToObject[id];
                    if (mesh && objects[id]) {
                        objects[id].position = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
                        objects[id].rotation = { x: mesh.rotation.x, y: mesh.rotation.y, z: mesh.rotation.z };
                        objects[id].scale = { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z };
                    }
                    objectsToSave[id] = objects[id];
                }
                const res = await fetch('/api/save_project', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name, objects: objectsToSave, room: currentRoom })
                });
                const data = await res.json();
                if (data.success) {
                    showCustomAlert('保存しました', window.innerWidth/2, 60);
                } else {
                    showCustomAlert('保存に失敗しました', window.innerWidth/2, 60);
                }
            };
        }

        function createObjectFromServer(obj, idToObject, selectableObjects) {
            if (idToObject[obj.id]) {
                scene.remove(idToObject[obj.id]);
                delete idToObject[obj.id];
            }
            let mesh;
            if (obj.type === 'cube') {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({ color: obj.color || 0x00ff00 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(obj.position.x, obj.position.y, obj.position.z);
                if (obj.rotation) mesh.rotation.set(obj.rotation.x, obj.rotation.y, obj.rotation.z);
                if (obj.scale) mesh.scale.set(obj.scale.x, obj.scale.y, obj.scale.z);
                scene.add(mesh);
                selectableObjects.push(mesh);
                idToObject[obj.id] = mesh;
                mesh.userData.serverId = obj.id;
            } else if (obj.type === 'sphere') {
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({ color: obj.color || 0x2196f3 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(obj.position.x, obj.position.y, obj.position.z);
                if (obj.rotation) mesh.rotation.set(obj.rotation.x, obj.rotation.y, obj.rotation.z);
                if (obj.scale) mesh.scale.set(obj.scale.x, obj.scale.y, obj.scale.z);
                scene.add(mesh);
                selectableObjects.push(mesh);
                idToObject[obj.id] = mesh;
                mesh.userData.serverId = obj.id;
            } else if (obj.type === 'plane') {
                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.MeshStandardMaterial({ color: obj.color || 0x9e9e9e, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(obj.position.x, obj.position.y, obj.position.z);
                if (obj.rotation) mesh.rotation.set(obj.rotation.x, obj.rotation.y, obj.rotation.z);
                if (obj.scale) mesh.scale.set(obj.scale.x, obj.scale.y, obj.scale.z);
                scene.add(mesh);
                selectableObjects.push(mesh);
                idToObject[obj.id] = mesh;
                mesh.userData.serverId = obj.id;
            } else if (obj.type === 'glb' && obj.modelName) {
                const loader = new THREE.GLTFLoader();
                loader.load(
                    `/static/models/${obj.modelName}`,
                    function (gltf) {
                        const model = gltf.scene;
                        model.position.set(obj.position.x, obj.position.y, obj.position.z);
                        if (obj.rotation) model.rotation.set(obj.rotation.x, obj.rotation.y, obj.rotation.z);
                        if (obj.scale) model.scale.set(obj.scale.x, obj.scale.y, obj.scale.z);
                        scene.add(model);
                        selectableObjects.push(model);
                        idToObject[obj.id] = model;
                        model.userData.serverId = obj.id;
                        objects[obj.id] = {
                            id: obj.id,
                            type: obj.type,
                            position: { x: model.position.x, y: model.position.y, z: model.position.z },
                            rotation: { x: model.rotation.x, y: model.rotation.y, z: model.rotation.z },
                            scale: { x: model.scale.x, y: model.scale.y, z: model.scale.z },
                            color: obj.color || undefined,
                            modelName: obj.modelName || undefined
                        };
                    }
                );
                return;
            } else {
                return;
            }
            objects[obj.id] = {
                id: obj.id,
                type: obj.type,
                position: { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z },
                rotation: { x: mesh.rotation.x, y: mesh.rotation.y, z: mesh.rotation.z },
                scale: { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z },
                color: obj.color || undefined,
                modelName: obj.modelName || undefined
            };
        }

        function updateObjectState(id, mesh) {
            if (objects[id]) {
                objects[id].position = { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z };
                objects[id].rotation = { x: mesh.rotation.x, y: mesh.rotation.y, z: mesh.rotation.z };
                objects[id].scale = { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z };
            }
        }

        const undoStack = [];
        function pushUndo(action) {
            undoStack.push(action);
            if (undoStack.length > 100) undoStack.shift();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }
    </script>
</body>
</html>
